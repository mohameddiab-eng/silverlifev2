<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tetris</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="style.css">
    <style>
        .tetris-grid-container {
            background-color: #0d121c; /* Very dark background for the game area */
            border: 8px solid #2a3447; /* Thicker, slightly lighter border */
            margin-top: 20px;
            display: flex;
            flex-direction: row; /* Layout changed to row for game info and grid */
            align-items: flex-start; /* Align items to the top */
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
        }
        .tetris-grid {
            display: grid;
            grid-template-columns: repeat(10, 25px);
            grid-template-rows: repeat(20, 25px);
            background-color: #000; /* Pure black for the main game grid */
            border: 2px solid #374151;
            box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.8);
            margin-right: 20px; /* Space between grid and info */
        }
        .grid-cell {
            width: 25px;
            height: 25px;
            background-color: #1a1a1a; /* Dark gray for empty cells, subtle contrast */
            border: 1px solid #0a0a0a; /* Darker border for cell separation */
            box-sizing: border-box; /* Include padding and border in the element's total width and height */
        }
        .next-piece-display {
            width: 100px; /* Adjusted width */
            height: 100px;
            background-color: #000; /* Pure black for next piece display */
            border: 2px solid #374151;
            margin-top: 0; /* No top margin here, handled by flex container */
            display: grid;
            grid-template-columns: repeat(4, 25px);
            grid-template-rows: repeat(4, 25px);
            align-items: center;
            justify-content: center;
            box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.8);
        }
        .tetris-block {
            /* background-color will be set by JS */
            border: 1px solid rgba(255, 255, 255, 0.2); /* Light border for block distinction */
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5), 0 0 8px rgba(0, 0, 0, 0.3); /* Inner shadow for depth */
            transition: background-color 0.1s ease-out; /* Smooth color changes */
        }
        /* Mobile controls specific styling */
        .mobile-controls {
            display: flex; /* Ensure flex layout */
            flex-wrap: wrap; /* Allow buttons to wrap on smaller screens */
            justify-content: center; /* Center buttons */
            gap: 10px; /* Space between buttons */
        }
        .mobile-controls button {
            min-width: 60px; /* Minimum width for touch targets */
            min-height: 60px; /* Minimum height for touch targets */
            font-size: 1.5rem; /* Larger icons for touch */
            background-color: #374151; /* Darker button background */
            color: #e5e7eb; /* Light text/icon color */
            border: none; /* Remove default border */
            border-radius: 50%; /* Make them circular */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); /* Subtle shadow */
            transition: background-color 0.2s ease, transform 0.1s ease; /* Smooth transitions */
        }
        .mobile-controls button:hover {
            background-color: #4b5563; /* Slightly lighter on hover */
        }
        .mobile-controls button:active {
            transform: scale(0.95); /* Visual feedback on press */
        }
    </style>
</head>
<body class="h-screen overflow-hidden flex flex-col entertainment-theme transition-all duration-500">
    <!-- Accessibility Bar -->
    <div id="access-bar">
        <div class="flex justify-between items-center mb-4 border-b pb-2">
            <h3 class="font-bold text-lg text-gray-800">Accessibility</h3>
            <button onclick="toggleAccessBar()" class="text-gray-500 text-xl"><i class="fas fa-times"></i></button>
        </div>
        
        <div class="mb-5">
            <p class="text-sm text-gray-600 mb-2 font-bold">Text Size</p>
            <div class="flex gap-2">
                <button onclick="setAccess('size', 'normal')" class="flex-1 bg-gray-200 text-gray-800 p-2 rounded text-sm hover:bg-gray-300">A</button>
                <button onclick="setAccess('size', 'large')" class="flex-1 bg-gray-200 text-gray-800 p-2 rounded text-lg font-bold hover:bg-gray-300">A+</button>
                <button onclick="setAccess('size', 'xl')" class="flex-1 bg-gray-200 text-gray-800 p-2 rounded text-xl font-bold hover:bg-gray-300">A++</button>
            </div>
        </div>

        <div class="mb-5">
            <p class="text-sm text-gray-600 mb-2 font-bold">Display Mode</p>
            <div class="space-y-2">
                <button onclick="setAccess('mode', 'light')" class="w-full bg-white text-gray-800 p-3 rounded font-bold border border-gray-300 flex items-center justify-center gap-2 shadow-sm">
                    <i class="fas fa-sun text-yellow-500"></i> Light Mode
                </button>
                 <button onclick="setAccess('mode', 'dark')" class="w-full bg-gray-800 text-white p-3 rounded font-bold border border-gray-600 flex items-center justify-center gap-2">
                    <i class="fas fa-moon"></i> Dark Mode
                </button>
                <button onclick="setAccess('mode', 'contrast')" class="w-full bg-black text-yellow-400 p-3 rounded font-bold border-2 border-yellow-400 flex items-center justify-center gap-2">
                    <i class="fas fa-adjust"></i> High Contrast
                </button>
            </div>
        </div>

        <div class="mb-5">
            <p class="text-sm text-gray-600 mb-2 font-bold">Voice Assistant</p>
            <div class="flex gap-2">
                <button onclick="readPage()" class="flex-1 bg-blue-100 text-blue-800 p-3 rounded font-bold flex items-center justify-center gap-2 hover:bg-blue-200">
                    <i class="fas fa-volume-up"></i> Read
                </button>
                <button onclick="stopReading()" class="w-16 bg-red-100 text-red-800 p-3 rounded font-bold flex items-center justify-center hover:bg-red-200">
                    <i class="fas fa-stop"></i>
                </button>
            </div>
        </div>

        <button onclick="setAccess('reset')" class="w-full bg-gray-200 text-gray-700 p-3 rounded font-bold mt-4 hover:bg-gray-300 border border-gray-300">
            <i class="fas fa-undo mr-1"></i> Reset Settings
        </button>
    </div>

    <!-- Header -->
    <header class="bg-teal-600 text-white p-4 shadow-md z-30 sticky top-0 flex justify-between items-center h-16">
        <div class="flex items-center gap-2">
            <button id="menu-button" class="bg-teal-700 w-10 h-10 rounded-full flex items-center justify-center tap-effect border border-teal-500 shadow-sm" aria-label="Menu">
                <i class="fas fa-bars text-lg"></i>
            </button>
            <img src="SA.png" alt="Tetris Logo" class="w-8 h-8 rounded-full mr-2 app-logo">
            <h1 class="text-2xl font-bold truncate">Tetris</h1>
        </div>
        <div class="flex items-center gap-2">
            <select id="game-switcher" class="bg-teal-700 text-white p-2 rounded-full text-sm mr-2 tap-effect focus:ring-2 focus:ring-teal-400">
                <option value="entertainment.html">Games Hub</option>
                <option value="tetris.html" selected>Tetris</option>
                <option value="tictactoe.html">Tic-Tac-Toe</option>
                <option value="sudoku.html">Sudoku</option>
             
            </select>
            <button onclick="toggleAccessBar()" class="bg-teal-700 w-10 h-10 rounded-full flex items-center justify-center tap-effect border border-teal-500 shadow-sm" aria-label="Accessibility Settings">
                <i class="fas fa-eye text-lg"></i>
            </button>
        </div>
    </header>
    <audio id="tetris-audio" src="tetris_song.mp3" loop preload="auto"></audio>

    <!-- Main Content -->
    <main class="flex-1 overflow-y-auto no-scrollbar p-4 relative flex flex-col items-center">
        <section id="tetris" class="page-section active flex flex-col items-center">
            <div class="bg-purple-100 border-l-4 border-purple-500 p-4 mb-4 rounded-lg text-center">
                <p id="game-status" class="text-purple-900 font-bold text-lg">Get Ready!</p>
            </div>
            
            <div class="tetris-grid-container flex-row items-start gap-4">
                <div class="game-info flex flex-col items-center p-4 bg-gray-800/90 rounded-lg shadow-md">
                    <h3 class="text-white text-xl font-bold mb-3">Next Piece</h3>
                    <div class="next-piece-display" id="next-piece-display">
                        <!-- Next Tetris piece will be shown here -->
                    </div>
                    <div class="mt-6 w-full">
                        <h3 class="text-white text-xl font-bold mb-2">Score: <span id="score" class="text-yellow-400">0</span></h3>
                        <h3 class="text-white text-xl font-bold mb-2">Lines: <span id="lines" class="text-green-400">0</span></h3>
                        <h3 class="text-white text-xl font-bold">Level: <span id="level" class="text-blue-400">1</span></h3>
                    </div>
                    <button id="mute-button" class="mt-4 bg-gray-700 text-white font-bold py-2 px-4 rounded-xl shadow-lg tap-effect hover:bg-gray-600 flex items-center justify-center gap-2">
                        <i class="fas fa-volume-up"></i> <span id="mute-text">Mute</span>
                    </button>
                </div>
                <div class="tetris-grid" id="tetris-grid">
                    <!-- Tetris grid cells will be generated by JavaScript -->
                </div>
            </div>
            
            <div class="flex gap-4 mt-6">
                <button id="start-game-btn" class="bg-purple-600 text-white font-bold py-3 px-6 rounded-xl shadow-lg tap-effect hover:bg-purple-700">Start Game</button>
                <button id="pause-game-btn" class="bg-gray-400 text-white font-bold py-3 px-6 rounded-xl shadow-lg tap-effect hover:bg-gray-500">Pause</button>
                <button id="reset-game-btn" class="bg-red-500 text-white font-bold py-3 px-6 rounded-xl shadow-lg tap-effect hover:bg-red-600">Reset</button>
            </div>
            
            <!-- Mobile Controls -->
            <div class="mobile-controls mt-8 w-full flex justify-center gap-4 md:hidden">
                <button id="move-left" class="bg-gray-700 text-white p-4 rounded-full text-2xl tap-effect"><i class="fas fa-arrow-left"></i></button>
                <button id="rotate" class="bg-gray-700 text-white p-4 rounded-full text-2xl tap-effect"><i class="fas fa-redo-alt"></i></button>
                <button id="move-right" class="bg-gray-700 text-white p-4 rounded-full text-2xl tap-effect"><i class="fas fa-arrow-right"></i></button>
                <button id="soft-drop" class="bg-gray-700 text-white p-4 rounded-full text-2xl tap-effect"><i class="fas fa-arrow-down"></i></button>
                <button id="hard-drop" class="bg-gray-700 text-white p-4 rounded-full text-2xl tap-effect"><i class="fas fa-angle-double-down"></i></button>
            </div>
        </section>
    </main>

    <!-- Sidebar Menu -->
    <div id="sidebar-menu">
        <div class="p-4 border-b border-gray-200">
            <h2 class="text-xl font-bold text-gray-800">Menu</h2>
        </div>
        <a href="index.html" class="menu-item home-bg"><i class="fas fa-home"></i> Home</a>
        <a href="shop.html" class="menu-item shop-bg"><i class="fas fa-shopping-cart"></i> Shop List</a>
        <a href="wellness.html" class="menu-item wellness-bg"><i class="fas fa-heart"></i> Exercise</a>
        <a href="contacts.html" class="menu-item contacts-bg"><i class="fas fa-phone"></i> Call</a>
        <a href="meds.html" class="menu-item meds-bg"><i class="fas fa-pills"></i> Medicine</a>
        <a href="schedule.html" class="menu-item schedule-bg"><i class="fas fa-list-alt"></i> Schedule</a>
        <a href="tasks.html" class="menu-item tasks-bg"><i class="fas fa-check"></i> To-Do</a>
        <a href="notes.html" class="menu-item notes-bg"><i class="fas fa-pen"></i> My Diary</a>
        <a href="entertainment.html" class="menu-item entertainment-bg"><i class="fas fa-gamepad"></i> Entertainment</a>
    </div>

    <!-- Menu Overlay -->
    <div id="menu-overlay"></div>

    <script src="script.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            applyAccessSettings();
            
            const tetrisGrid = document.getElementById('tetris-grid');
            const nextPieceDisplay = document.getElementById('next-piece-display');
            const scoreDisplay = document.getElementById('score');
            const linesDisplay = document.getElementById('lines');
            const levelDisplay = document.getElementById('level');
            const gameStatus = document.getElementById('game-status');
            const startGameBtn = document.getElementById('start-game-btn');
            const pauseGameBtn = document.getElementById('pause-game-btn');
            const resetGameBtn = document.getElementById('reset-game-btn');
            const tetrisAudio = document.getElementById('tetris-audio');
            const muteButton = document.getElementById('mute-button');
            const muteText = document.getElementById('mute-text');
            let isMuted = false;

            // Mobile controls
            const moveLeftBtn = document.getElementById('move-left');
            const rotateBtn = document.getElementById('rotate');
            const moveRightBtn = document.getElementById('move-right');
            const softDropBtn = document.getElementById('soft-drop');
            const hardDropBtn = document.getElementById('hard-drop');

            // Game switcher logic
            const gameSwitcher = document.getElementById('game-switcher');
            gameSwitcher.addEventListener('change', (event) => {
                window.location.href = event.target.value;
            });

            const GRID_WIDTH = 10;
            const GRID_HEIGHT = 20;
            const BLOCK_SIZE = 25; // px
            let gameBoard = Array(GRID_HEIGHT).fill(0).map(() => Array(GRID_WIDTH).fill(0));

            let currentPiece = null;
            let nextPiece = null;
            let score = 0;
            let lines = 0;
            let level = 1;
            let gameOverState = true;
            let gamePaused = false;
            let gameInterval = null;
            let dropTime = 1000; // milliseconds

            // Tetromino shapes (coordinates relative to top-left of 4x4 block)
            const TETROMINOS = [
                // I
                [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]],
                [[0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0]],
                // J
                [[1, 0, 0], [1, 1, 1], [0, 0, 0]],
                [[0, 1, 1], [0, 1, 0], [0, 1, 0]],
                [[0, 0, 0], [1, 1, 1], [0, 0, 1]],
                [[0, 1, 0], [0, 1, 0], [1, 1, 0]],
                // L
                [[0, 0, 1], [1, 1, 1], [0, 0, 0]],
                [[0, 1, 0], [0, 1, 0], [0, 1, 1]],
                [[0, 0, 0], [1, 1, 1], [1, 0, 0]],
                [[1, 1, 0], [0, 1, 0], [0, 1, 0]],
                // O
                [[1, 1], [1, 1]],
                // S
                [[0, 1, 1], [1, 1, 0], [0, 0, 0]],
                [[0, 1, 0], [0, 1, 1], [0, 0, 1]],
                // T
                [[0, 1, 0], [1, 1, 1], [0, 0, 0]],
                [[0, 1, 0], [0, 1, 1], [0, 1, 0]],
                [[0, 0, 0], [1, 1, 1], [0, 1, 0]],
                [[0, 1, 0], [1, 1, 0], [0, 1, 0]],
                // Z
                [[1, 1, 0], [0, 1, 1], [0, 0, 0]],
                [[0, 0, 1], [0, 1, 1], [0, 1, 0]]
            ];

            const COLORS = [
                '#00BCD4', // I - Cyan
                '#3F51B5', // J - Blue
                '#FF9800', // L - Orange
                '#FFEB3B', // O - Yellow
                '#4CAF50', // S - Green
                '#9C27B0', // T - Purple
                '#F44336'  // Z - Red
            ];

            function createGrid(container, width, height) {
                container.innerHTML = '';
                for (let i = 0; i < width * height; i++) {
                    const cell = document.createElement('div');
                    cell.classList.add('grid-cell');
                    container.appendChild(cell);
                }
            }

            createGrid(tetrisGrid, GRID_WIDTH, GRID_HEIGHT);
            createGrid(nextPieceDisplay, 4, 4); // 4x4 for next piece preview
            const gridCells = Array.from(tetrisGrid.children); // Get actual DOM elements

            function draw() {
                // Draw gameBoard (locked pieces)
                for (let r = 0; r < GRID_HEIGHT; r++) {
                    for (let c = 0; c < GRID_WIDTH; c++) {
                        const index = r * GRID_WIDTH + c;
                        if (gameBoard[r][c] !== 0) {
                            gridCells[index].style.backgroundColor = gameBoard[r][c];
                            gridCells[index].classList.add('tetris-block');
                        } else {
                            gridCells[index].style.backgroundColor = ''; // Default background
                            gridCells[index].classList.remove('tetris-block');
                        }
                    }
                }

                // Draw currentPiece
                if (currentPiece) {
                    currentPiece.shape.forEach((row, r) => {
                        row.forEach((value, c) => {
                            if (value === 1) {
                                const boardX = currentPiece.x + c;
                                const boardY = currentPiece.y + r;
                                const index = boardY * GRID_WIDTH + boardX;
                                if (boardX >= 0 && boardX < GRID_WIDTH && boardY >= 0 && boardY < GRID_HEIGHT) {
                                    gridCells[index].style.backgroundColor = currentPiece.color;
                                    gridCells[index].classList.add('tetris-block');
                                }
                            }
                        });
                    });
                }
            }

            function clearPiece(piece) {
                if (!piece) return;
                piece.shape.forEach((row, r) => {
                    row.forEach((value, c) => {
                        if (value === 1) {
                            const boardX = piece.x + c;
                            const boardY = piece.y + r;
                            const index = boardY * GRID_WIDTH + boardX;
                            if (boardX >= 0 && boardX < GRID_WIDTH && boardY >= 0 && boardY < GRID_HEIGHT && gameBoard[boardY][boardX] === 0) {
                                gridCells[index].style.backgroundColor = '';
                                gridCells[index].classList.remove('tetris-block');
                            }
                        }
                    });
                });
            }
            
            // Initial render
            draw();

            // Temporary: Generate a piece for visual test
            function getRandomTetromino() {
                const randomIndex = Math.floor(Math.random() * (TETROMINOS.length / 2)); // Each tetromino has 2-4 rotations
                const shape = TETROMINOS[randomIndex * 2]; // Get first rotation
                const color = COLORS[Math.floor(Math.random() * COLORS.length)];
                return { shape, x: Math.floor(GRID_WIDTH / 2) - Math.floor(shape[0].length / 2), y: 0, color, rotation: 0 };
            }
            currentPiece = getRandomTetromino();
            draw();


            // Event Listeners for buttons
            startGameBtn.addEventListener('click', () => {
                if (gameOverState || gamePaused) {
                    startGame();
                }
            });

            pauseGameBtn.addEventListener('click', () => {
                togglePause();
            });

            resetGameBtn.addEventListener('click', () => {
                resetGame();
            });

            muteButton.addEventListener('click', () => {
                isMuted = !isMuted;
                if (isMuted) {
                    tetrisAudio.pause();
                    muteButton.querySelector('i').classList.replace('fa-volume-up', 'fa-volume-mute');
                    muteText.textContent = "Unmute";
                } else {
                    if (!gameOverState && !gamePaused) {
                        tetrisAudio.play();
                    }
                    muteButton.querySelector('i').classList.replace('fa-volume-mute', 'fa-volume-up');
                    muteText.textContent = "Mute";
                }
            });

            // Placeholder for game functions (will be expanded)
            function startGame() {
                console.log('Game Started!');
                gameOverState = false;
                gamePaused = false;
                gameStatus.textContent = "Playing...";
                // Reset game state
                score = 0;
                lines = 0;
                level = 1;
                scoreDisplay.textContent = score;
                linesDisplay.textContent = lines;
                levelDisplay.textContent = level;
                gameBoard = Array(GRID_HEIGHT).fill(0).map(() => Array(GRID_WIDTH).fill(0));

                generateNewPiece();
                gameInterval = setInterval(gameLoop, dropTime);
                if (!isMuted) {
                    tetrisAudio.currentTime = 0;
                    tetrisAudio.play();
                }
            }

            function gameLoop() {
                clearPiece(currentPiece);
                currentPiece.y++;
                if (checkCollision()) {
                    currentPiece.y--;
                    lockPiece();
                    clearLines();
                    generateNewPiece();
                    if (checkCollision()) { // Game over if new piece immediately collides
                        gameOver();
                    }
                }
                draw();
            }

            function togglePause() {
                gamePaused = !gamePaused;
                if (gamePaused) {
                    clearInterval(gameInterval);
                    gameStatus.textContent = "Paused";
                    tetrisAudio.pause();
                } else {
                    gameInterval = setInterval(gameLoop, dropTime);
                    gameStatus.textContent = "Playing...";
                    if (!isMuted) {
                        tetrisAudio.play();
                    }
                }
            }

            function resetGame() {
                clearInterval(gameInterval);
                gameOverState = true;
                gamePaused = false;
                gameStatus.textContent = "Get Ready!";
                gameBoard = Array(GRID_HEIGHT).fill(0).map(() => Array(GRID_WIDTH).fill(0));
                currentPiece = null;
                nextPiece = null;
                score = 0;
                lines = 0;
                level = 1;
                scoreDisplay.textContent = score;
                linesDisplay.textContent = lines;
                levelDisplay.textContent = level;
                draw(); // Redraw empty board
                clearNextPieceDisplay();
                tetrisAudio.pause();
                tetrisAudio.currentTime = 0;
            }

            function generateNewPiece() {
                if (!nextPiece) {
                    nextPiece = getRandomTetromino();
                }
                currentPiece = nextPiece;
                nextPiece = getRandomTetromino();

                // Initial position for new piece
                currentPiece.x = Math.floor(GRID_WIDTH / 2) - Math.floor(currentPiece.shape[0].length / 2);
                currentPiece.y = 0; // Start at the top

                drawNextPiece();
            }

            function getRandomTetromino() {
                const tetrominoTypes = [
                    { shape: [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]], color: COLORS[0], rotations: 2 }, // I
                    { shape: [[1,0,0], [1,1,1], [0,0,0]], color: COLORS[1], rotations: 4 }, // J
                    { shape: [[0,0,1], [1,1,1], [0,0,0]], color: COLORS[2], rotations: 4 }, // L
                    { shape: [[1,1], [1,1]], color: COLORS[3], rotations: 1 }, // O
                    { shape: [[0,1,1], [1,1,0], [0,0,0]], color: COLORS[4], rotations: 2 }, // S
                    { shape: [[0,1,0], [1,1,1], [0,0,0]], color: COLORS[5], rotations: 4 }, // T
                    { shape: [[1,1,0], [0,1,1], [0,0,0]], color: COLORS[6], rotations: 2 }  // Z
                ];
                const randomIndex = Math.floor(Math.random() * tetrominoTypes.length);
                const { shape, color, rotations } = tetrominoTypes[randomIndex];
                return { shape, x: 0, y: 0, color, rotation: 0, rotations: rotations, typeIndex: randomIndex };
            }

            function checkCollision(piece = currentPiece) {
                for (let r = 0; r < piece.shape.length; r++) {
                    for (let c = 0; c < piece.shape[r].length; c++) {
                        if (piece.shape[r][c] === 1) {
                            const boardX = piece.x + c;
                            const boardY = piece.y + r;
                            if (boardX < 0 || boardX >= GRID_WIDTH || boardY >= GRID_HEIGHT || (boardY >= 0 && gameBoard[boardY][boardX] !== 0)) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            function lockPiece() {
                currentPiece.shape.forEach((row, r) => {
                    row.forEach((value, c) => {
                        if (value === 1) {
                            const boardX = currentPiece.x + c;
                            const boardY = currentPiece.y + r;
                            if (boardY >= 0 && boardY < GRID_HEIGHT) {
                                gameBoard[boardY][boardX] = currentPiece.color;
                            }
                        }
                    });
                });
            }

            function clearLines() {
                let linesClearedThisTurn = 0;
                for (let r = GRID_HEIGHT - 1; r >= 0; r--) {
                    if (gameBoard[r].every(cell => cell !== 0)) {
                        linesClearedThisTurn++;
                        // Remove full line and add empty line at top
                        gameBoard.splice(r, 1);
                        gameBoard.unshift(Array(GRID_WIDTH).fill(0));
                        r++; // Recheck the same row index as new line came down
                    }
                }
                if (linesClearedThisTurn > 0) {
                    lines += linesClearedThisTurn;
                    score += linesClearedThisTurn * 100 * level; // Simple scoring
                    linesDisplay.textContent = lines;
                    scoreDisplay.textContent = score;

                    // Increase level every 10 lines
                    if (lines >= level * 10) {
                        level++;
                        levelDisplay.textContent = level;
                        dropTime = Math.max(100, dropTime - 100); // Speed up
                        clearInterval(gameInterval);
                        gameInterval = setInterval(gameLoop, dropTime);
                    }
                }
            }

            function gameOver() {
                clearInterval(gameInterval);
                gameOverState = true;
                gameStatus.textContent = "Game Over!";
                tetrisAudio.pause();
            }

            function drawNextPiece() {
                const nextCells = Array.from(nextPieceDisplay.children);
                // Clear previous next piece
                nextCells.forEach(cell => {
                    cell.style.backgroundColor = '';
                    cell.classList.remove('tetris-block');
                });

                if (nextPiece) {
                    nextPiece.shape.forEach((row, r) => {
                        row.forEach((value, c) => {
                            if (value === 1) {
                                const index = r * 4 + c;
                                if (nextCells[index]) {
                                    nextCells[index].style.backgroundColor = nextPiece.color;
                                    nextCells[index].classList.add('tetris-block');
                                }
                            }
                        });
                    });
                }
            }

            function clearNextPieceDisplay() {
                const nextCells = Array.from(nextPieceDisplay.children);
                nextCells.forEach(cell => {
                    cell.style.backgroundColor = '';
                    cell.classList.remove('tetris-block');
                });
            }

            // Keyboard controls
            document.addEventListener('keydown', e => {
                if (gameOverState || gamePaused) return;

                clearPiece(currentPiece);
                switch (e.key) {
                    case 'ArrowLeft':
                        currentPiece.x--;
                        if (checkCollision()) currentPiece.x++;
                        break;
                    case 'ArrowRight':
                        currentPiece.x++;
                        if (checkCollision()) currentPiece.x--;
                        break;
                    case 'ArrowDown':
                        currentPiece.y++;
                        if (checkCollision()) {
                            currentPiece.y--;
                            lockPiece();
                            clearLines();
                            generateNewPiece();
                            if (checkCollision()) { gameOver(); }
                        }
                        break;
                    case 'ArrowUp': // Rotate
                        rotatePiece();
                        break;
                    case ' ': // Hard Drop
                        e.preventDefault(); // Prevent page scroll
                        while (!checkCollision()) {
                            currentPiece.y++;
                        }
                        currentPiece.y--;
                        lockPiece();
                        clearLines();
                        generateNewPiece();
                        if (checkCollision()) { gameOver(); }
                        break;
                }
                draw();
            });

            function rotatePiece() {
                const originalShape = currentPiece.shape;
                const N = originalShape.length;
                let newShape = Array(N).fill(0).map(() => Array(N).fill(0));

                for (let r = 0; r < N; r++) {
                    for (let c = 0; c < N; c++) {
                        newShape[c][N - 1 - r] = originalShape[r][c];
                    }
                }
                currentPiece.shape = newShape;
                if (checkCollision()) {
                    currentPiece.shape = originalShape; // Revert if collision
                }
            }

            // Mobile controls event listeners
            moveLeftBtn.addEventListener('click', () => {
                if (gameOverState || gamePaused) return;
                clearPiece(currentPiece);
                currentPiece.x--;
                if (checkCollision()) currentPiece.x++;
                draw();
            });

            moveRightBtn.addEventListener('click', () => {
                if (gameOverState || gamePaused) return;
                clearPiece(currentPiece);
                currentPiece.x++;
                if (checkCollision()) currentPiece.x--;
                draw();
            });

            rotateBtn.addEventListener('click', () => {
                if (gameOverState || gamePaused) return;
                clearPiece(currentPiece);
                rotatePiece();
                draw();
            });

            softDropBtn.addEventListener('click', () => {
                if (gameOverState || gamePaused) return;
                clearPiece(currentPiece);
                currentPiece.y++;
                if (checkCollision()) {
                    currentPiece.y--;
                    lockPiece();
                    clearLines();
                    generateNewPiece();
                    if (checkCollision()) { gameOver(); }
                }
                draw();
            });

            hardDropBtn.addEventListener('click', () => {
                if (gameOverState || gamePaused) return;
                clearPiece(currentPiece);
                while (!checkCollision()) {
                    currentPiece.y++;
                }
                currentPiece.y--;
                lockPiece();
                clearLines();
                generateNewPiece();
                if (checkCollision()) { gameOver(); }
                draw();
            });

        });
    </script>
</body>
</html>
